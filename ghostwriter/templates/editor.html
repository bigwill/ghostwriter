<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>ghostwriter</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x1f47b;</text></svg>">

<style>
*,*::before,*::after { margin:0; padding:0; box-sizing:border-box; }

:root {
  --bg:      #faf8f5;
  --fg:      #2c2c2c;
  --muted:   #b0a090;
  --ghost:   rgba(0,0,0,0.08);
  --accent:  #7a4e2d;
  --tag-bg:  rgba(122,78,45,0.10);
  --tag-bdr: rgba(122,78,45,0.35);
  --danger:  #a04040;
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg:      #1a1916;
    --fg:      #e0dbd4;
    --muted:   #6e6358;
    --ghost:   rgba(255,255,255,0.08);
    --accent:  #c9a57a;
    --tag-bg:  rgba(201,165,122,0.12);
    --tag-bdr: rgba(201,165,122,0.35);
    --danger:  #c06060;
  }
}

html { height:100%; }

body {
  font-family: Georgia, 'Times New Roman', 'Noto Serif', serif;
  background: var(--bg);
  color: var(--fg);
  min-height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem 1.25rem 3rem;
  -webkit-font-smoothing: antialiased;
}

.container { max-width: 40em; width: 100%; }

/* ---- header ---- */
.brand {
  font-variant: small-caps;
  letter-spacing: 0.18em;
  color: var(--muted);
  font-size: 0.75rem;
  text-align: center;
  margin-bottom: 0.5rem;
}
.brand a { color: inherit; text-decoration: none; }

#status {
  text-align: center;
  color: var(--muted);
  font-size: 0.8rem;
  font-style: italic;
  margin-bottom: 1.5rem;
  min-height: 1.2em;
  transition: opacity 0.3s;
}
#status.ready { opacity: 0; pointer-events: none; height: 0; min-height: 0; margin: 0; }

/* ---- steps ---- */
.step { display: none; }
.step.active { display: block; }

/* ---- textarea ---- */
textarea {
  width: 100%;
  min-height: 45vh;
  font-family: inherit;
  font-size: 1.1rem;
  line-height: 1.9;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--ghost);
  border-radius: 6px;
  padding: 1.25rem;
  resize: vertical;
  transition: border-color 0.2s;
}
textarea:focus { outline: none; border-color: var(--accent); }
textarea::placeholder { color: var(--muted); }

/* ---- inputs & buttons ---- */
.field {
  margin: 1rem 0;
}
input[type="text"] {
  width: 100%;
  font-family: inherit;
  font-size: 1rem;
  padding: 0.65rem 1rem;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--ghost);
  border-radius: 6px;
  transition: border-color 0.2s;
}
input:focus { outline: none; border-color: var(--accent); }
input::placeholder { color: var(--muted); }

.actions {
  display: flex;
  gap: 0.75rem;
  align-items: center;
  margin-top: 1.25rem;
  flex-wrap: wrap;
}
.spacer { flex: 1; }

button {
  font-family: inherit;
  font-size: 0.9rem;
  padding: 0.6rem 1.3rem;
  background: var(--accent);
  color: var(--bg);
  border: none;
  border-radius: 6px;
  cursor: pointer;
  white-space: nowrap;
  transition: opacity 0.2s;
  -webkit-tap-highlight-color: transparent;
}
button:active { opacity: 0.8; }
button:disabled { opacity: 0.4; cursor: default; }

.ghost-btn {
  background: transparent;
  color: var(--muted);
  border: 1px solid var(--ghost);
  font-size: 0.85rem;
  padding: 0.5rem 1rem;
}
.ghost-btn:active { background: var(--ghost); }

.muted-text {
  color: var(--muted);
  font-size: 0.82rem;
  font-style: italic;
}

/* ---- poem words (tagging view) ---- */
.poem-words {
  font-size: 1.1rem;
  line-height: 2.2;
  padding: 0.75rem 0;
}
.poem-line { min-height: 1.4em; }
.blank-line { height: 1.8em; }

.word {
  cursor: pointer;
  padding: 0.12em 0.15em;
  border-radius: 4px;
  transition: all 0.15s;
  -webkit-tap-highlight-color: transparent;
}
.word:hover { background: var(--tag-bg); }
.word.tagged {
  background: var(--tag-bg);
  border-bottom: 2px solid var(--accent);
  color: var(--accent);
  font-weight: 600;
}

/* ---- morph results ---- */
.morphed-word {
  color: var(--accent);
  cursor: pointer;
  border-bottom: 1px dotted var(--tag-bdr);
  padding: 0.1em 0;
  transition: background 0.15s;
  -webkit-tap-highlight-color: transparent;
}
.morphed-word:hover,
.morphed-word:active {
  background: var(--tag-bg);
}

/* ---- alternatives overlay ---- */
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.35);
  display: flex;
  align-items: flex-end;
  justify-content: center;
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s;
}
.overlay.open {
  opacity: 1;
  pointer-events: auto;
}

.alt-panel {
  background: var(--bg);
  border-radius: 16px 16px 0 0;
  padding: 1.5rem 1.5rem 2rem;
  width: 100%;
  max-width: 40em;
  max-height: 60vh;
  overflow-y: auto;
  transform: translateY(100%);
  transition: transform 0.25s ease-out;
}
.overlay.open .alt-panel {
  transform: translateY(0);
}

.alt-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid var(--ghost);
}
.alt-original {
  color: var(--muted);
  font-size: 0.85rem;
  font-style: italic;
}
.alt-close {
  background: none;
  border: none;
  color: var(--muted);
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0.3rem;
}

.alt-options {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}
.alt-opt {
  display: block;
  width: 100%;
  text-align: left;
  font-family: inherit;
  font-size: 1.05rem;
  padding: 0.7rem 1rem;
  background: transparent;
  color: var(--fg);
  border: none;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.15s;
}
.alt-opt:hover,
.alt-opt:active { background: var(--tag-bg); }
.alt-opt.selected {
  color: var(--accent);
  font-weight: 600;
  background: var(--tag-bg);
}
.alt-check {
  display: inline-block;
  width: 1.1em;
  height: 1.1em;
  border: 2px solid var(--muted);
  border-radius: 4px;
  margin-right: 0.6rem;
  vertical-align: -0.15em;
  position: relative;
  transition: all 0.15s;
  flex-shrink: 0;
}
.alt-opt.selected .alt-check {
  border-color: var(--accent);
  background: var(--accent);
}
.alt-opt.selected .alt-check::after {
  content: '';
  position: absolute;
  left: 3px; top: 0px;
  width: 5px; height: 9px;
  border: solid var(--bg);
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}
.alt-score {
  float: right;
  font-size: 0.75rem;
  color: var(--muted);
  font-weight: normal;
}
.alt-custom {
  display: flex;
  gap: 0.5rem;
  margin-top: 0.75rem;
  padding-top: 0.75rem;
  border-top: 1px solid var(--ghost);
}
.alt-custom input {
  flex: 1;
  font-family: inherit;
  font-size: 0.95rem;
  padding: 0.5rem 0.75rem;
  background: transparent;
  color: var(--fg);
  border: 1px solid var(--ghost);
  border-radius: 6px;
}
.alt-custom input:focus { outline: none; border-color: var(--accent); }
.alt-custom input::placeholder { color: var(--muted); }
.alt-custom button {
  font-size: 0.85rem;
  padding: 0.5rem 0.9rem;
}

/* ---- share result ---- */
.share-result { margin-top: 1.25rem; }
.url-box {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.65rem 1rem;
  background: var(--ghost);
  border-radius: 8px;
}
.url-box a {
  flex: 1;
  color: var(--accent);
  font-family: monospace;
  font-size: 0.85rem;
  text-decoration: none;
  word-break: break-all;
}
.url-box button {
  font-size: 0.8rem;
  padding: 0.35rem 0.75rem;
}

/* ---- nav ---- */
.nav {
  text-align: center;
  margin-top: 2.5rem;
  font-size: 0.8rem;
}
.nav a { color: var(--muted); text-decoration: none; }
.nav a:hover { text-decoration: underline; }

/* ---- responsive ---- */
@media (max-width: 480px) {
  body { padding: 1.5rem 1rem 2.5rem; }
  textarea { min-height: 35vh; font-size: 1rem; padding: 1rem; }
  .poem-words { font-size: 1rem; line-height: 2; }
}

/* ---- cycling morphed words ---- */
.morphed-word {
  transition: opacity 0.35s ease;
}
.morphed-word.fading {
  opacity: 0;
}
.cycle-count {
  font-size: 0.6em;
  color: var(--muted);
  vertical-align: super;
  margin-left: 0.1em;
  font-style: normal;
}

/* ---- loading spinner ---- */
@keyframes pulse { 0%,100% { opacity:0.4; } 50% { opacity:1; } }
.loading { animation: pulse 1.5s ease-in-out infinite; }
</style>
</head>
<body>

<div class="container">

  <p class="brand"><a href="/">ghostwriter</a></p>
  <div id="status" class="loading">loading word embeddings...</div>

  <!-- ======================= Step 1: Write ======================= -->
  <section id="step-write" class="step active">
    <textarea id="poem-text" placeholder="write or paste something..." autofocus></textarea>
    <div class="field">
      <input id="vibe-input" type="text" placeholder="vibe -- e.g. dread, warmth, alien">
    </div>
    <div class="actions">
      <span class="spacer"></span>
      <button id="btn-prepare" onclick="prepare()" disabled>tag words</button>
    </div>
  </section>

  <!-- ======================= Step 2: Tag ========================= -->
  <section id="step-tag" class="step">
    <p class="muted-text" style="margin-bottom:0.5rem">tap words to tag them for morphing</p>
    <div id="poem-words" class="poem-words"></div>
    <div class="actions">
      <button class="ghost-btn" onclick="backToWrite()">edit</button>
      <span class="spacer"></span>
      <span id="tag-count" class="muted-text"></span>
      <button id="btn-morph" onclick="doMorph()" disabled>morph</button>
    </div>
  </section>

  <!-- ======================= Step 3: Result ====================== -->
  <section id="step-result" class="step">
    <div id="result-poem" class="poem-words"></div>
    <div class="actions">
      <button class="ghost-btn" onclick="backToTag()">re-tag</button>
      <span class="spacer"></span>
      <button id="btn-save" onclick="savePoem()">save & share</button>
    </div>
    <div id="share-result" class="share-result" style="display:none">
      <div class="url-box">
        <a id="share-link" href="#" target="_blank"></a>
        <button onclick="copyUrl()">copy</button>
      </div>
    </div>
  </section>

  <nav class="nav"><a href="/">writings</a></nav>
</div>

<!-- ======================= Alternatives overlay ================== -->
<div id="alt-overlay" class="overlay" onclick="closeAlts(event)">
  <div class="alt-panel" onclick="event.stopPropagation()">
    <div class="alt-header">
      <span id="alt-original" class="alt-original"></span>
      <button class="alt-close" onclick="closeAlts()">done</button>
    </div>
    <div id="alt-options" class="alt-options"></div>
    <div class="alt-custom">
      <input id="alt-custom-input" type="text" placeholder="add a word...">
      <button onclick="addCustomWord()">add</button>
    </div>
  </div>
</div>

<script>
// =====================================================================
// State
// =====================================================================
const WORD_RE = /[A-Za-z]+/g;
const API_KEY = {{ api_key | default('', true) | tojson }};

function apiHeaders() {
  const h = {'Content-Type': 'application/json'};
  if (API_KEY) h['X-Api-Key'] = API_KEY;
  return h;
}

let poemLines = [];    // [{tokens: [{text, isWord, tagged, idx}]}]
let nextIdx = 0;
// morphData[idx] = {original, originalLower, candidates, selectedWords[], customWords[]}
let morphData = {};
let altTarget = null;  // idx of word showing alternatives
let cycleTimer = null;
let cycleIdx = 0;

// =====================================================================
// Helpers
// =====================================================================

function showStep(name) {
  document.querySelectorAll('.step').forEach(el => el.classList.remove('active'));
  document.getElementById('step-' + name).classList.add('active');
  if (name === 'result') startCycling();
  else stopCycling();
}

function matchCase(original, replacement) {
  if (!original || !replacement) return replacement;
  if (original === original.toUpperCase() && original.length > 1)
    return replacement.toUpperCase();
  if (original[0] === original[0].toUpperCase())
    return replacement[0].toUpperCase() + replacement.slice(1);
  return replacement;
}

function needsAn(word) {
  return word && 'aeiou'.includes(word[0].toLowerCase());
}

function adjustArticle(morphedEl, newWord) {
  // Look at the previous text node; if it ends with " a " or " an ",
  // swap to match the new word's leading sound.
  const prev = morphedEl.previousSibling;
  if (!prev || prev.nodeType !== 3) return;
  const t = prev.textContent;
  const vowel = needsAn(newWord);
  const fixed = t.replace(/(^|\s)(a|an|A|An|AN)\s$/, function(_, pre, art) {
    let target = vowel ? 'an' : 'a';
    if (art === art.toUpperCase() && art.length > 1) target = target.toUpperCase();
    else if (art[0] === art[0].toUpperCase()) target = target[0].toUpperCase() + target.slice(1);
    return pre + target + ' ';
  });
  if (fixed !== t) prev.textContent = fixed;
}

function tokenizeLine(line) {
  const tokens = [];
  let last = 0;
  const re = /[A-Za-z]+/g;
  let m;
  while ((m = re.exec(line)) !== null) {
    if (m.index > last)
      tokens.push({text: line.slice(last, m.index), isWord: false});
    tokens.push({text: m[0], isWord: true, tagged: false, idx: nextIdx++});
    last = m.index + m[0].length;
  }
  if (last < line.length)
    tokens.push({text: line.slice(last), isWord: false});
  return tokens;
}

function getLineContext(line) {
  return line.tokens.filter(t => t.isWord).map(t => t.text.toLowerCase());
}

function getAllTagged() {
  const out = [];
  poemLines.forEach(line => {
    line.tokens.forEach(tok => { if (tok.isWord && tok.tagged) out.push(tok); });
  });
  return out;
}

// =====================================================================
// Status polling
// =====================================================================

function pollStatus() {
  fetch('/api/status')
    .then(r => r.json())
    .then(data => {
      const el = document.getElementById('status');
      if (data.model_ready) {
        el.textContent = 'ready';
        el.classList.remove('loading');
        el.classList.add('ready');
        document.getElementById('btn-prepare').disabled = false;
      } else {
        setTimeout(pollStatus, 2000);
      }
    })
    .catch(() => setTimeout(pollStatus, 3000));
}
pollStatus();

// =====================================================================
// Step 1 -> Step 2: Prepare tagging
// =====================================================================

function prepare() {
  const text = document.getElementById('poem-text').value;
  const vibe = document.getElementById('vibe-input').value.trim();
  if (!text.trim()) return;
  if (!vibe) {
    const inp = document.getElementById('vibe-input');
    inp.focus();
    inp.style.borderColor = 'var(--danger)';
    setTimeout(() => inp.style.borderColor = '', 1500);
    return;
  }

  nextIdx = 0;
  poemLines = text.split('\n').map(line => ({tokens: tokenizeLine(line)}));
  renderTagView();
  showStep('tag');
}

function renderTagView() {
  const container = document.getElementById('poem-words');
  container.innerHTML = '';

  poemLines.forEach(line => {
    if (line.tokens.length === 0 || (line.tokens.length === 1 && !line.tokens[0].text.trim())) {
      const div = document.createElement('div');
      div.className = 'blank-line';
      container.appendChild(div);
      return;
    }

    const div = document.createElement('div');
    div.className = 'poem-line';

    line.tokens.forEach(tok => {
      if (tok.isWord) {
        const span = document.createElement('span');
        span.className = 'word' + (tok.tagged ? ' tagged' : '');
        span.textContent = tok.text;
        span.dataset.idx = tok.idx;
        span.addEventListener('click', () => {
          tok.tagged = !tok.tagged;
          span.classList.toggle('tagged');
          updateTagCount();
        });
        div.appendChild(span);
      } else {
        div.appendChild(document.createTextNode(tok.text));
      }
    });

    container.appendChild(div);
  });

  updateTagCount();
}

function updateTagCount() {
  const tagged = getAllTagged();
  const el = document.getElementById('tag-count');
  el.textContent = tagged.length ? tagged.length + ' tagged' : '';
  document.getElementById('btn-morph').disabled = tagged.length === 0;
}

function backToWrite() {
  showStep('write');
}

// =====================================================================
// Step 2 -> Step 3: Morph
// =====================================================================

function doMorph() {
  const vibe = document.getElementById('vibe-input').value.trim();
  const tagged = getAllTagged();
  if (!tagged.length || !vibe) return;

  const words = tagged.map(tok => {
    const line = poemLines.find(l => l.tokens.includes(tok));
    return {
      word: tok.text.toLowerCase(),
      context: line ? getLineContext(line) : [],
    };
  });

  const btn = document.getElementById('btn-morph');
  btn.disabled = true;
  btn.textContent = 'morphing...';

  function attempt() {
    fetch('/api/morph', {
      method: 'POST',
      headers: apiHeaders(),
      body: JSON.stringify({vibe, words}),
    })
    .then(r => {
      if (r.status === 503) {
        // Model still loading — wait and retry
        btn.textContent = 'waiting for model...';
        setTimeout(attempt, 3000);
        return null;
      }
      if (!r.ok) throw new Error('Server returned ' + r.status);
      return r.json();
    })
    .then(data => {
      if (!data) return; // 503 retry in progress
      if (data.error) { alert(data.error); return; }

      morphData = {};

      data.results.forEach((result, i) => {
        const tok = tagged[i];
        // Start with the original word, then add top candidate
        const selected = [result.original];
        if (result.candidates.length > 0) {
          const top = result.candidates[0].word;
          if (top !== result.original) selected.push(top);
        }
        morphData[tok.idx] = {
          original: tok.text,
          originalLower: result.original,
          candidates: result.candidates,
          selectedWords: selected,
          customWords: [],
        };
      });

      renderResult();
      showStep('result');
      btn.disabled = false;
      btn.textContent = 'morph';
    })
    .catch(err => {
      alert('Morph failed: ' + err.message);
      btn.disabled = false;
      btn.textContent = 'morph';
    });
  }
  attempt();
}

// =====================================================================
// Step 3: Render results + cycling
// =====================================================================

function renderResult() {
  const container = document.getElementById('result-poem');
  container.innerHTML = '';

  poemLines.forEach(line => {
    if (line.tokens.length === 0 || (line.tokens.length === 1 && !line.tokens[0].text.trim())) {
      const div = document.createElement('div');
      div.className = 'blank-line';
      container.appendChild(div);
      return;
    }

    const div = document.createElement('div');
    div.className = 'poem-line';

    line.tokens.forEach(tok => {
      const md = morphData[tok.idx];
      if (md && md.selectedWords.length > 0) {
        const display = matchCase(md.original, md.selectedWords[0]);
        const span = document.createElement('span');
        span.className = 'morphed-word';
        span.textContent = display;
        span.title = 'was: ' + md.original;
        span.dataset.idx = tok.idx;
        span.dataset.original = md.original;
        span.dataset.words = JSON.stringify(md.selectedWords);
        span.addEventListener('click', () => showAlts(tok.idx));
        if (md.selectedWords.length > 1) {
          const badge = document.createElement('span');
          badge.className = 'cycle-count';
          badge.textContent = md.selectedWords.length;
          span.appendChild(badge);
        }
        div.appendChild(span);
      } else {
        div.appendChild(document.createTextNode(tok.text));
      }
    });

    container.appendChild(div);
  });

  document.getElementById('share-result').style.display = 'none';

  // restart cycling with new data
  if (document.getElementById('step-result').classList.contains('active')) {
    startCycling();
  }
}

function startCycling() {
  stopCycling();
  // Track current index per element to avoid repeats
  document.querySelectorAll('#result-poem .morphed-word').forEach(el => {
    el._ci = 0;
  });
  cycleTimer = setInterval(() => {
    document.querySelectorAll('#result-poem .morphed-word').forEach(el => {
      const words = JSON.parse(el.dataset.words || '[]');
      if (words.length <= 1) return;
      const orig = el.dataset.original;
      // Pick a random index different from current
      const cur = el._ci || 0;
      let next = Math.floor(Math.random() * (words.length - 1));
      if (next >= cur) next++;
      el._ci = next;
      const w = matchCase(orig, words[next]);
      el.classList.add('fading');
      setTimeout(() => {
        const badge = el.querySelector('.cycle-count');
        el.textContent = w;
        if (badge) el.appendChild(badge);
        adjustArticle(el, words[next]);
        el.classList.remove('fading');
      }, 350);
    });
  }, 3000);
}

function stopCycling() {
  if (cycleTimer) { clearInterval(cycleTimer); cycleTimer = null; }
}

// =====================================================================
// Alternatives overlay (multi-select + custom words)
// =====================================================================

function showAlts(idx) {
  altTarget = idx;
  const md = morphData[idx];
  if (!md) return;

  document.getElementById('alt-original').textContent = 'was: ' + md.original;
  const container = document.getElementById('alt-options');
  container.innerHTML = '';

  // Combine candidates + custom words into a unified list
  const allWords = md.candidates.map(c => ({word: c.word, score: c.score, custom: false}));
  md.customWords.forEach(w => {
    if (!allWords.find(a => a.word === w)) {
      allWords.push({word: w, score: null, custom: true});
    }
  });

  allWords.forEach(item => {
    const btn = document.createElement('button');
    const isSelected = md.selectedWords.includes(item.word);
    btn.className = 'alt-opt' + (isSelected ? ' selected' : '');

    const display = matchCase(md.original, item.word);
    let inner = '<span class="alt-check"></span>' + display;
    if (item.score !== null) {
      inner += '<span class="alt-score">' + item.score.toFixed(3) + '</span>';
    } else {
      inner += '<span class="alt-score">custom</span>';
    }
    btn.innerHTML = inner;
    btn.addEventListener('click', () => toggleWord(idx, item.word));
    container.appendChild(btn);
  });

  document.getElementById('alt-custom-input').value = '';
  document.getElementById('alt-overlay').classList.add('open');
}

function toggleWord(idx, word) {
  const md = morphData[idx];
  const i = md.selectedWords.indexOf(word);
  if (i >= 0) {
    md.selectedWords.splice(i, 1);
  } else {
    md.selectedWords.push(word);
  }
  // re-render the overlay to update checkboxes
  showAlts(idx);
  renderResult();
}

function addCustomWord() {
  if (altTarget === null) return;
  const input = document.getElementById('alt-custom-input');
  const word = input.value.trim().toLowerCase();
  if (!word || !/^[a-z]+$/i.test(word)) return;

  const md = morphData[altTarget];
  if (!md.customWords.includes(word)) {
    md.customWords.push(word);
  }
  if (!md.selectedWords.includes(word)) {
    md.selectedWords.push(word);
  }

  input.value = '';
  showAlts(altTarget);
  renderResult();
}

// Handle Enter key in custom word input
document.getElementById('alt-custom-input').addEventListener('keydown', e => {
  if (e.key === 'Enter') { e.preventDefault(); addCustomWord(); }
});

function closeAlts(e) {
  if (e && e.target !== document.getElementById('alt-overlay')) return;
  document.getElementById('alt-overlay').classList.remove('open');
  altTarget = null;
}

function backToTag() {
  showStep('tag');
  renderTagView();
}

// =====================================================================
// Save & Share
// =====================================================================

function fixArticlesInText(text) {
  // Fix "a <vowel-word>" → "an <vowel-word>" and vice versa
  return text.replace(/\b(a|an|A|An|AN)\s+([A-Za-z])/g, function(m, art, ch) {
    const vowel = 'aeiou'.includes(ch.toLowerCase());
    let target = vowel ? 'an' : 'a';
    if (art === art.toUpperCase() && art.length > 1) target = target.toUpperCase();
    else if (art[0] === art[0].toUpperCase()) target = target[0].toUpperCase() + target.slice(1);
    return target + ' ' + ch;
  });
}

function buildFinalText() {
  let text = '';
  poemLines.forEach((line, li) => {
    if (li > 0) text += '\n';
    line.tokens.forEach(tok => {
      const md = morphData[tok.idx];
      if (md && md.selectedWords.length > 0) {
        text += matchCase(md.original, md.selectedWords[0]);
      } else {
        text += tok.text;
      }
    });
  });
  return fixArticlesInText(text);
}

function buildWordCycles() {
  // {originalLower: [word1, word2, ...]}
  const cycles = {};
  for (const idx in morphData) {
    const md = morphData[idx];
    if (md.selectedWords.length > 0) {
      cycles[md.originalLower] = md.selectedWords;
    }
  }
  return cycles;
}

function savePoem() {
  const text = buildFinalText();
  const wordCycles = buildWordCycles();
  const btn = document.getElementById('btn-save');
  btn.disabled = true;
  btn.textContent = 'saving...';

  fetch('/api/save', {
    method: 'POST',
    headers: apiHeaders(),
    body: JSON.stringify({text, morphed: wordCycles}),
  })
  .then(r => r.json())
  .then(data => {
    const shareDiv = document.getElementById('share-result');
    shareDiv.style.display = 'block';
    const link = document.getElementById('share-link');
    link.href = data.url;
    link.textContent = data.full_url;
    link.dataset.url = data.full_url;
  })
  .catch(err => alert('Save failed: ' + err.message))
  .finally(() => {
    btn.disabled = false;
    btn.textContent = 'save & share';
  });
}

function copyUrl() {
  const url = document.getElementById('share-link').dataset.url;
  if (navigator.clipboard) {
    navigator.clipboard.writeText(url).then(() => {
      const btn = event.target;
      const orig = btn.textContent;
      btn.textContent = 'copied!';
      setTimeout(() => btn.textContent = orig, 2000);
    });
  } else {
    const ta = document.createElement('textarea');
    ta.value = url;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
  }
}
</script>
</body>
</html>
